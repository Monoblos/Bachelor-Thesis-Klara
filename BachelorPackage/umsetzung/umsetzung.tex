%!TEX root = ../thesis.tex

\chapter{Umsetzung}

In diesem Kapitel wird detailliert die Umsetzung der in Kapitel~\ref{sec:anforderungen} dargelegten Anforderungen an die Software beschrieben. Hierbei werden auch verschiedene andere m"ogliche Umsetzungen vorgestellt und erkl"art warum diese nicht zum Einsatz gekommen sind.

Wichtig ist hierbei auch der letzte Punkt der Lizenzierung, da diese konform zu der Lizenz des verwendeten Frameworks "`ASM"' sein musste.

\section{Konsolen Interface}
\label{sec:console}

Bei der Realisierung des Konsolen Interface war besonders die intuitive Benutzbarkeit und "Ubersichtlichkeit wichtig. Sowohl bei der Wahl der Parameter f"ur die Ausf"uhrung, als auch bei der erzeugten Ausgabe.

Das intuitivste Bedienkonzept f"ur eine Konsolen-Anwendung ist der Aufruf mit Parametern. Durch diese werden alle Optionen gesetzt und das Programm ben"otigt keine Interaktion w"ahrend der Ausf"uhrung. Der Nachteil ist allerdings ganz offensichtlich: Der Nutzer muss zum starten des Programms zuerst die Liste der verf"ugbaren Parameter und deren Bedeutung kennen. Zudem k"onnen Aufrufe sehr schnell sehr lang werden, was die "Ubersichtlichkeit einschr"ankt.

Trotz dieser Nachteile ist die M"oglichkeit eines parametrisierten Aufrufs unverzichtbar f"ur eine Programm mit ausschlie"slich textueller Oberfl"ache. F"ur die Implementierung existieren in Java einige Bibliotheken und Framerworks, wie Beispielsweise:
\begin{itemize}
	\item Commons CLI
	\item Java Gems
	\item JArgs
	\item GetOpt
	\item Args4J
	\item JCommando
\end{itemize}

Allerdings haben alle den Nachteil, das sie nur "`"ubliche"' Formate unterst"utzen. F"ur besondere Parameterformate muss eine eigene verarbeiten erfolgen, welche auch zus"atzlich den Vorteil bietet, dass somit keine weiteren Abh"angigkeiten der Software geschaffen werden.

Die eigene Implementierung dieser Parameterverarbeitung erfolgt Schleifen-basiert. "Uber einen if-else-Baum wird jeder einzelne Parameter verarbeitet. Da sich die Verarbeitung im Variablenkontext der Schleife befindet, kann diese die Parameterliste durchsuchen und, wenn ben"otigt, beliebig viele weitere Parameter, die als Argumente dienen, verwenden. Auch die Abbruchbedingung f"ur das verarbeiten von Parametern kann frei gew"ahlt werden. So k"onnte Beispielsweise eine End-Option eingef"uhrt werden, welche das verarbeiten der Parameter beendet und die verbleibenden an das Haupt-Programm weiter leitet. In der Gew"ahlten Implementierung bricht die Verarbeitung ab sobald ein Parameter gefunden wird der nicht mit einem '-' beginnt. Dieser wird als Identifikator f"ur das zu ladende Hauptprogramm interpretiert. Sollten weitere Parameter vorhanden sein werden diese als "`args"' weitergegeben. Somit ist eine klare Trennung der zu verarbeitenden und der weiter zu gebenden Parametern vorhanden.

F"ur die gesamte Implementierung gilt das bei invaliden Parameter-Kombinationen oder fehlenden Parametern eine entsprechende Fehlermeldung ausgegeben wird, gefolgt von der Hilfe wie in Listing~\ref{code:usage} dargestellt und das Programm dann mit einem Fehlercode abbricht. Alle Fehlercodes sind als Konstanten deklariert um eine Nachvollziehbarkeit von Code zu Ursache zu erzeugen.

\lstinputlisting[label=code:usage,caption=Hilfe Ausgabe mit Parametererkl\"arung]{umsetzung/usage.txt} 

Weitere M"ogliche Bedienkonzepte sind ein navigierbares Men"u und ein interaktiver Modus.

Bei dem navigierbaren Men"u k"onnte man dann mit Hilfe der einzelnen Optionen eine Konfiguration erstellen, diese potenziell abspeichern und damit starten. Dieses Konzept ist besonders f"ur komplexe Einstellungen geeignet, da es die M"oglichkeit bietet, in einer "ubersichtlichen Form eine reihe von Optionen zu w"ahlen. Dies kommt jedoch mit dem Nachteil, das selbst einfache Konfigurationen vergleichsweise lange zum erstellen ben"otigen. Zudem ist ein Men"u in der Implementierung aufw"andig.

Ein interaktiver Modus hingegen ist die Einsteiger freundlichste Methode. Hierbei wird durch eine Reihe von Fragen der User nach dem gew"unschten Einstellungen gefragt, in einer geordneten Reihenfolge und mit der M"oglichkeit f"ur ausf"uhrlichere Erkl"arungen der Option. Auch hier ist ein klarer Nachteil das einfache Konfigurationen, im Vergleich zu einem Parametrisierten-Start, l"anger zum starten ben"otigen. Der gro"se Vorteil ist jedoch, das auch unerfahrene Nutzer direkt die Software benutzen k"onnen. Die definierte Reihenfolge und das pr"ufen von Eingaben sorgen daf"ur, das Konfigurationen immer Valide sind.

Aufgrund der Zielgruppe der Anwendung, Programmiereinsteigern mit einfachen Programmen, ist eine einfache Benutzung wichtiger als die M"oglichkeit komplexe Konfigurationen zu erstellen.

\section{Individueller Class-Loader}



\section{Transformer} 



\subsection{Event Struktur} 



\subsection{Erstellte Implementierungen} 


Referenz aufs Codebeispiel \ref{code:minspring}.

\lstinputlisting[language=Java,label=code:minspring,caption=Codebeispiel Java]{techGrundlagen/minimalSpringBoot.java} 

\section{Lizenzierung} 

ASM Lizens bla blub \cite{asm_license}

Also alles easy, geht fast jede Lizenz wenn man LIZENZ.txt in die jar packt.