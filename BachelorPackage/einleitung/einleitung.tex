%!TEX root = ../thesis.tex

\chapter{Einleitung}

Um ein fundiertes Verständnis von Java zu erreichen und um ein grundlagenorientiertes Lernen zu ermöglichen, hilft es, anfänglich nur mit einem normalen Texteditor-Code zu schreiben und diesen dann selbst mittels Konsole zu kompilieren.
Mit diesem Ansatz dauert es möglicherweise etwas länger bis der erste ausführbare Code entsteht, jedoch ist der Lernerfolg größer, da alle Schritte dorthin selbst ausgeführt wurden und damit transparent sind.

Da es gerade Anfängern schwerfällt, die Ursache von Problemen zu finden, welche nicht bereits vom Compiler erkannt werden können, kann dies jedoch schnell mühsam werden. Selbst simple Probleme, wie eine falsch definierte Bedingung in einer Schleife oder Verzweigung, stellen hier ein ernstes Hindernis dar.

Hierbei soll "`Klara"' zum Einsatz kommen. Es hilft dabei, den Ablauf des Programms zu verstehen, ohne den Code dafür ändern zu müssen oder eine schwergewichtige \ac{IDE} zu verwenden.

In dieser Thesis wird dazu zuerst einmal auf die Problemstellung eingegangen. Hierbei wird beleuchtet, warum die Entwicklung nötig war und welche Rolle das Programm einnehmen soll.
Im zweiten Kapitel beschäftigt sich diese Arbeit mit der Analyse von Umgebung und Anforderungen. Hier wird auch darauf eingegangen was man genau unter tracing versteht und welche Einsatz-Szenarien möglich sind.
Im darauffolgenden Abschnitt werden die 3 wichtigen technischen Grundlagen genauer dargelegt: Bytecode, ASM und \ac{JDI}.
Da somit die Rahmenbedingungen der Arbeit klar sein sollten, wird in Kapitel 4 die Umsetzung genau erklärt.

Die wichtigen Aspekte hierbei sind:
\begin{itemize}
	\item Das Konsolen-Interface, über das der Nutzer die Anwendung bedient
	\item Der individuelle \code{ClassLoader}, welcher eine Manipulation des ausgeführten Codes ermöglicht
	\item Der Transformer, welcher modulare Änderungen ausführen kann
	\item Die Lizenzierung, um konform zu der Lizenz des verwendeten Framework zu bleiben
\end{itemize}

Schlussendlich wird in einem Fazit das Ergebnis der Arbeit reflektiert, ein Ausblick auf mögliche weitere zukünftige Funktionen gegeben und es werden andere potenzielle Anwendungsbereiche für die verwendete Technologie dargelegt.

\section{Problemstellung} 

Im Java Umfeld gibt es eine Reihe von Tools zum debuggen von Anwendungen, jedoch sind diese alle große und meist komplexe Programme. Zudem sind diese auch häufig Teil einer \ac{IDE} und nicht ohne diese einsetzbar.
In anderen Programmiersprachen, wie beispielsweise C, gibt es hierzu auch große und mächtige Hilfsmittel auf der Kommandozeile. Das wahrscheinlich bekannteste ist der \ac{DDD}. Bei moderneren Programmiersprachen ist dies jedoch zunehmend verloren gegangen, da heute nahezu jeder mit einer \ac{IDE} arbeitet, welche in der Regel einen grafischen Debugger mit sich bringt.

Viele Anfänger benutzen deshalb von Anfang an eine \ac{IDE}, um bei Problemen auf den Debugger der Umgebung zurückgreifen zu können, jedoch ist dies nicht zielführend. Zum einen sind die integrierten Debugger meist sehr komplex, was Anfängern auch das Finden einfacher Fehler schwer macht. Zum anderen kommt die Umgebung mit zahlreichen anderen Features, welche viele Schritte kombinieren und Anfängern nicht ersichtlich machen, was genau passiert.